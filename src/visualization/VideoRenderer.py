from typing import Dict, List, Any
import os 
import sys
import platform
import time
import PySide6.QtGui

import numpy as np

from qtpy.QtGui import *
from qtpy.QtCore import *
from qtpy.QtWidgets import *
from qtpy.QtWebEngineWidgets import *

from dotenv import load_dotenv

from src.utils.DataFlowHandler import DataFlowHandler, ResultGetters
from src.utils.CustomBasicWidgets import QHLine
from src.utils.PlotlyUtils import named_mesh_from_volume
from src.utils.util_enumy import *
from src.visualization.qimage_util import ndarray_to_rgb_native

import plotly.graph_objects as go
import multiprocessing as mp
import psutil
import io
from PIL import Image
import cv2
from timeit import default_timer as timer

import functools

def sigmoid(x):
    return 1.0 / (1.0 + np.exp(-x))

def render_volume(step, vol, background, label, width, height):
    """
        Global method for rendering a 3D volume. Has to be global
        for multiprocessing to work properly.

        Args:
            step: timestep in which volume appears
            vol: data structure for volume generated by network
            background: datastructure for background volume data
            label: datastructure for label volume data
            width, height: render resolution
    """
    p = psutil.Process()
    p.cpu_affinity(range(psutil.cpu_count()))
    fig = go.Figure()
    fig.add_traces([background, label, vol])
    fig_bytes = fig.to_image(format="jpg", width=width, height=height)
    buf = io.BytesIO(fig_bytes)
    img = Image.open(buf)
    ret = np.asarray(img)
    img.close()
    return step, ret

def render_image(step, img):
    """
        Renders 2D image and returns numpy array.
    """
    img = sigmoid(img)
    rgb_array = cv2.cvtColor(np.uint8(img*255), cv2.COLOR_BGRA2RGB)
    image = Image.fromarray(rgb_array, mode='RGB')
    return step, rgb_array

class VideoRendererHelpBox:
    """
        Simple info box with text and optional icon.
    """

    @staticmethod
    def show_message(text, icon=QMessageBox.Information):
        msg_box = QMessageBox()
        msg_box.setIcon(icon)
        msg_box.setText(text)
        msg_box.setWindowTitle("Video Renderer Help")
        msg_box.setStandardButtons(QMessageBox.Ok)
        
        msg_box.exec_()

class OutputVideoRenderer(QWidget):

    progress_signal = Signal()

    resolutions: List[str] = ['1920x1080', '1600x900', '1280x1024', '1152x864', '1024x768', '800x600', '720x400', '640x480']

    output_available: bool = False
    netoutput: Dict[int, np.ndarray]
    base: np.ndarray
    label: np.ndarray
    dataflowhandler: DataFlowHandler
    agent_result_retriever: ResultGetters            
    run_timer: QTimer
    curr_runtime: QTime
    image_preview: QLabel
    parent: QWidget

    preview_size : QSize = QSize(640, 480)

    def __init__(self, dataflowhandler: DataFlowHandler, parent: QWidget):
        """
            Generates VideoRenderer GUI elements.
        """

        super().__init__()
        self.parent = parent
        self.dataflowhandler = dataflowhandler
        self.output_available = False
        self.resolution = tuple(map(int, self.resolutions[-1].split('x')))
        self.n_proc_range = np.arange(1, int(psutil.cpu_count() * 0.75))
        self.n_proc = 4
        self.mp_group = "render_group"
        self.out_file = "output.avi"
        self.fps = 1
        self.render_progress = 0

        #gui stuff
        self.layout = QGridLayout()

        self.resolution_combo = QComboBox()
        self.resolution_combo.addItems(self.resolutions)
        self.resolution_combo.currentTextChanged.connect(self.update_res)
        self.resolution_combo.setCurrentIndex(len(self.resolutions)-1)

        self.n_proc_slider = QSlider(Qt.Orientation.Horizontal)
        self.n_proc_slider.setRange(self.n_proc_range.min(), self.n_proc_range.max())
        self.n_proc_slider.setValue(self.n_proc)
        self.n_proc_slider.valueChanged.connect(self.update_n_proc)

        self.n_proc_lbl = QLabel(f"Processes: {self.n_proc}")

        self.render_status_lbl = QLabel(f"Rendering Status: ")
        self.render_status_info_lbl = QLabel("Done")

        self.output_file_lbl = QLabel(self.out_file)
        self.output_file_btn = QPushButton("...")
        self.output_file_btn.setMaximumWidth(self.output_file_btn.sizeHint().width())
        self.output_file_btn.clicked.connect(self.update_output_file)

        self.fps_spinner = QSpinBox(self)
        self.fps_spinner.setRange(1, 24)
        self.fps_spinner.valueChanged.connect(self.update_fps)

        self.status_lbl = QLabel("Network Output Status: ")
        self.status_info_lbl = QLabel("Unavailable")
        self.status_info_lbl.setStyleSheet("color : red")

        self.output_shape_lbl = QLabel()
        self.output_interp_lbl = QLabel()
        
        self.help_btn = QPushButton("Help")
        self.help_btn.clicked.connect(self.show_help)

        self.current_data_point_lbl = QLabel("Current Datapoint: ")
        self.current_data_point_info_lbl = QLabel("None")

        # settings for 2D output
        self.channels_lbl = QLabel("Channels: ")
        self.channel_edit = QLineEdit()
        self.channel_edit.setValidator(QRegularExpressionValidator("(\d+,\s*)+\d+"))
        self.channel_edit.setMaxLength(64)
        self.check_channels_btn = QPushButton("check")
        self.check_channels_btn.setMaximumWidth(self.check_channels_btn.sizeHint().width())
        self.check_channels_btn.clicked.connect(self.check_channels)
        self.channel_interp_combo = QComboBox()
        self.channel_interp_combo.addItems(["RGBA", "Intensity"])

        # settings for 3D output
        self.channel_lbl = QLabel("Channel: ")
        self.channel_spinner = QSpinBox()

        self.render_btn = QPushButton("render")
        self.render_btn.clicked.connect(self.render)

        self.image_preview = QLabel()
        self.image_preview.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.image_preview.setText("Nothing to show")
        self.image_preview.setFixedSize(self.preview_size)

        self.render_progress_bar = QProgressBar(self)

        row = 0
        self.layout.addWidget(self.status_lbl, row, 0)
        self.layout.addWidget(self.status_info_lbl, row, 1)
        self.layout.addWidget(self.output_shape_lbl, row, 2)
        self.layout.addWidget(self.help_btn, row, 3, Qt.AlignmentFlag.AlignRight)
        row += 1
        self.layout.addWidget(self.current_data_point_lbl, row, 0)
        self.layout.addWidget(self.current_data_point_info_lbl, row, 1)
        self.layout.addWidget(self.output_interp_lbl, row, 2)
        row+=1
        self.layout.addWidget(QHLine(), row, 0, 1, 5)
        row+=1
        self.layout.addWidget(self.n_proc_lbl, row, 0)
        self.layout.addWidget(self.n_proc_slider, row, 1, 1, 2)
        self.layout.addWidget(QLabel("Resolution: "), row, 3)
        self.layout.addWidget(self.resolution_combo, row, 4)
        row+=1
        self.layout.addWidget(QLabel("Output File: "), row, 0)
        self.layout.addWidget(self.output_file_lbl, row, 1)
        self.layout.addWidget(self.output_file_btn, row, 2)
        self.layout.addWidget(QLabel("FPS: "), row, 3)
        self.layout.addWidget(self.fps_spinner, row, 4)
        row+=1
        self.layout.addWidget(QHLine(), row, 0, 1, 5)
        row+=1
        self.layout.addWidget(QLabel("Settings for 2D output: "), row, 0)
        row+=1
        self.layout.addWidget(self.channels_lbl, row, 0)
        self.layout.addWidget(self.channel_edit, row, 1)
        self.layout.addWidget(self.check_channels_btn, row, 2, 1, 1)
        self.layout.addWidget(self.channel_interp_combo, row, 3, 1, 1)
        row+=1
        self.layout.addWidget(QHLine(), row, 0, 1, 5)
        row+=1
        self.layout.addWidget(QLabel("Settings for 3D output: "), row, 0)
        row+=1
        self.layout.addWidget(self.channel_lbl, row, 0)
        self.layout.addWidget(self.channel_spinner, row, 1)
        row+=1
        self.layout.addWidget(QHLine(), row, 0, 1, 5)
        row+=1
        self.layout.addWidget(self.render_status_lbl, row, 0)
        self.layout.addWidget(self.render_status_info_lbl, row, 1)
        row+=1
        self.layout.addWidget(self.render_progress_bar, row, 0, 1, 5)
        row+=1
        self.layout.addWidget(self.render_btn, row, 0, 1, 5)
        row+=1
        self.layout.addWidget(QHLine(), row, 0, 1, 5)
        row+=1
        # self.layout.addWidget(QLabel("Preview:"), row, 0, 1, 5, Qt.AlignmentFlag.AlignCenter)
        # row+=1
        # self.layout.addWidget(self.image_preview, row, 0, 1, 5)

        self.setLayout(self.layout)

        # print(f"LAYOUT: {self.layout.sizeHint()}")

        # register for network output
        self.dataflowhandler.add_network_handler(self.update_network_data)

        # create new group for video rendering and register for it

        # this guard is needed for when the video renderer gets opened multiple times throughout the application
        if not self.dataflowhandler.exist_group(self.mp_group): #leads to deadlock?
            self.dataflowhandler.create_group(self.mp_group)
        self.dataflowhandler.add_handler_function(self.finish_rendering, self.mp_group)

        self.run_timer = QTimer()
        self.run_timer.timeout.connect(self.update_runtime)

        self.curr_runtime = QTime(0, 0, 0)

        self.progress_signal.connect(self.update_progress)

    def check_channels(self, showmsg=True):
        """
            Checks if channel input field contains valid channels for current network output.
        """
        valid = self.channel_edit.hasAcceptableInput()
        if not valid:
            VideoRendererHelpBox.show_message("Input invalid, regex failed!", QMessageBox.Warning)
            return False, None
        
        channels = self.channel_edit.text()
        channel_tpl = eval(channels)
        # VideoRendererHelpBox.show_message(f"Channels: {channel_tpl}")
        msg = f"Channels valid"

        if self.output_available:
            output_channels = self.netoutput.shape[-1]
            if not all(x < output_channels for x in channel_tpl):
                VideoRendererHelpBox.show_message("Invalid channels", QMessageBox.Warning)
                return False, None
        else:
            msg += " \nNOTE: netoutput was not available at time of check"
        
        if showmsg: VideoRendererHelpBox.show_message(msg)
        return True, channel_tpl


    def show_help(self):
        VideoRendererHelpBox.show_message("""
The network output can be either 2D or 3D and must have shape 
    (STEPS, w, h [, z], c)
The timesteps will be used for the video frames.
In the case of 2D, the z axis will not be present. Here you can additionally choose which channels should be rendered. There are 3 modes in which your data can be interpreted: 
    RGB for 3 channels
    RGBA for 4 channels
    GRAY for 1 channel
At the moment only RGBA is implemented.                                    
In the case of 3D, you can choose the channel which should be used for rendering. Only a single channel can be rendered. You can turn off overlay rendering of the label.
""")

    def update_runtime(self):
        """
            Used for measuring rendering runtime.
        """
        self.curr_runtime = self.curr_runtime.addSecs(1)
        self.render_status_info_lbl.setText("Rendering" + ("." * (self.curr_runtime.second()%5)))

    def update_progress(self):
        """
            Pushes ahead progressbar by one step.
        """
        # step, img = ret
        # if self.current_frame is not None:
        #     print(self.current_frame.shape)
        #     self.update_image_preview(self.current_frame)

        self.render_progress += 1
        self.render_progress_bar.setValue(self.render_progress)

    # not used
    def update_image_preview(self, img: np.ndarray):
        qimg = ndarray_to_rgb_native(img)
        self.image_preview.setPixmap(QPixmap(qimg).scaled(self.preview_size))
        self.image_preview.setText("")

    def reset_image_preview(self):
        # self.image_preview.setPixmap(QPixmap())
        # self.image_preview.setText("Nothing to show")
        self.image_preview.setAlignment(Qt.AlignmentFlag.AlignCenter)

    def update_output_file(self):
        """
            Used for setting the path to the output file. Shows a file dialog.
        """
        path = os.getcwd()
        file, _ = QFileDialog.getSaveFileName(self, "Set Output File", path, "*.avi")

        if file != "":
            self.out_file = file
            self.output_file_lbl.setText(self.out_file)

    def update_fps(self):
        """
            Update fps parameter.
        """
        self.fps = self.fps_spinner.value()

    def finish_rendering(self, ret):
        """
            Called when rendering finished. Updates all relevant GUI elements.
        """
        #TODO does this run in a different thread? (breaks the timer sometimes)
        self.run_timer.stop()
        uuid, stats = ret
        stats = stats[self.mp_group]
        print(stats)
        self.render_status_info_lbl.setText(f"Done after {self.curr_runtime.second()}s")
        self.render_btn.setEnabled(True)
        self.curr_runtime = QTime(0, 0, 0)

    def unregister(self):
        self.dataflowhandler.remove_network_handler(self.update_network_data)

    def update_res(self):
        self.resolution = tuple(map(int, self.resolution_combo.currentText().split('x')))

    def update_n_proc(self):
        self.n_proc = self.n_proc_slider.value()
        self.n_proc_lbl.setText(f"Processes: {self.n_proc}")

    def update_network_data(self, data):
        """
            Update GUI elements with new network data received from dataflowhandler
        """
        _, updates = data
        keys = list(updates.keys())
        update = updates[keys[0]]
        if update[0] == FlowDataChangeType.ABSDIFF:
            return
        update = update[1]
        if len(update) == 1: # only info about agent update
            return

        tupd, data, fname = update
        self.output_available = True

        self.update_status_label()
        self.current_data_point_info_lbl.setText(fname)
        self.netoutput = data
        self.base, self.label = self.dataflowhandler.get_image_for_filename(fname)
        self.label = self.label.squeeze()

        timesteps = list(self.netoutput.keys())[1:]
        self.netoutput = np.array([self.netoutput[x] for x in timesteps])
        # only use the actual network output
        #self.netoutput # self.netoutput[..., 1]
        self.output_shape_lbl.setText(f"Output shape: {self.netoutput.shape}")
        # self.output_interp_lbl.setText("Shape interpretation: (STEPS, w, h [, z], c)")
        self.is3D = len(self.netoutput.shape) == 5
        n_channels = self.netoutput.shape[-1]

        # update GUI elements
        if self.is3D:
            self.channel_lbl.setEnabled(True)
            self.channel_spinner.setEnabled(True)

            self.channels_lbl.setEnabled(False)
            self.channel_edit.setEnabled(False) 
            self.check_channels_btn.setEnabled(False)
            self.channel_interp_combo.setEnabled(False)

            self.channel_spinner.setRange(0, n_channels)
        else:
            self.channels_lbl.setEnabled(True)
            self.channel_edit.setEnabled(True) 
            self.check_channels_btn.setEnabled(True)
            self.channel_interp_combo.setEnabled(True)

            self.channel_lbl.setEnabled(False)
            self.channel_spinner.setEnabled(False)
            
        self.fps_spinner.setRange(1, len(timesteps))

    def update_status_label(self):

        if self.output_available:
            self.status_info_lbl.setText("Available")
            self.status_info_lbl.setStyleSheet("color : green")
        else:
            self.status_info_lbl.setText("Unavailable")
            self.status_info_lbl.setStyleSheet("color : red")

    def render(self):
        """
            Initialize GUI elements for rendering start.
        """
        channel = None
        channels = None

        if not self.output_available:
            VideoRendererHelpBox.show_message("No network output available")
            return

        if not self.is3D:
            success, channels = self.check_channels(showmsg=False)
        else:
            channel = self.channel_spinner.value()
            success = channel <= self.netoutput.shape[-1]

        if success:
            self.render_progress_bar.setValue(0)
            self.render_btn.setEnabled(False)
            self.render_status_info_lbl.setText("Rendering")
            self.run_timer.start(1000)
            self.dataflowhandler.run_function_in_group(self.__render_internal, self.mp_group, kwargs={"channels":  channels, "channel": channel})

    def __render_internal(self, channels, channel):
        """
            Starts multiprocessed rendering in a process pool.
        Args:
            channels    only supplied when netoutput is 2D
            channel     only supplied when netoutput is 3D
        """

        if not self.output_available:
            return
        
        print(f"Shapes: labels {self.label.shape} ", end="")
        print(f" base {self.base.shape}", end="")
        print(f" netoutput {self.netoutput.shape}")

        n_timesteps = self.netoutput.shape[0]

        render_func = None
        prepared_netout = None
        
        #decide whether to render 2D or 3D
        if len(self.netoutput.shape) == 4: #2D (STEP, w, h, c)
            print(f"Rendering 2D output")

            prepared_netout = self.netoutput[..., :4]
            sliced = self.netoutput[(Ellipsis, channels)]
            prepared_netout = sliced
            _, width, height, _ = self.netoutput.shape

            method = self.channel_interp_combo.currentText()

            if method == "RGBA" and not len(channels) == 4:
                VideoRendererHelpBox.show_message("Need 4 channels for RGBA rendering", QMessageBox.Warning)
                return False
            elif method == "Intensity" and not len(channels) == 1:
                VideoRendererHelpBox.show_message("Need 1 channel for intensity rendering", QMessageBox.Warning)
                return False
            
            if method == "RGBA":
                render_func = render_image
            elif method == "Intensity":
                #TODO: use merge_image_label_gt
                pass

        elif len(self.netoutput.shape) == 5: #3D (STEP, w, h, z, c)
            width, height = self.resolution
            print(f"Rendering 3D output")
            background_mesh = named_mesh_from_volume(self.base, "background", 0.3, "gray")
            label_mesh = named_mesh_from_volume(self.label, "label", 0.3, "plasma")
            prepared_netout = [named_mesh_from_volume(vol, f"netout", 0.5, "inferno") for vol in self.netoutput[..., channel]]
            f = functools.partial(render_volume, background=background_mesh, label=label_mesh, width=width, height=height)

            render_func = f
        else: #not supported
            VideoRendererHelpBox.show_message("Unsupported network output shape!", QMessageBox.Warning)
            return False


        fps = self.fps
        print(f"target video resolution: {width} x {height}")
        start = timer()
        self.render_progress_bar.setRange(0, n_timesteps)
        self.render_progress = 0

        def progress_callback(ret):
            step, img = ret
            self.current_frame = img
            self.progress_signal.emit()

        with mp.Pool(processes=self.n_proc) as pool:

            async_results = [pool.apply_async(render_func, args=(timestep, netout), callback=progress_callback) for timestep, netout in zip(range(n_timesteps), prepared_netout)]
            print("Started rendering")
            results = [res.get() for res in async_results]
            frames = []
            for step, frame in results:
                frames.append(frame)

        end = timer()
        rendering_time = end-start
        print(f"Worker pool finished after {rendering_time}")

        start = timer()
        video_writer = cv2.VideoWriter(self.out_file, cv2.VideoWriter_fourcc(*'MJPG'), fps, (width, height))
        # frames[-1] = cv2.cvtColor(frames[-1], cv2.COLOR_RGB2BGR)
        # cv2.imwrite("cv2.jpg", frames[-1])
        for frame in frames:
            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
            video_writer.write(frame)

        video_writer.release()
        end = timer()
        disk_writer_time = end-start
        times = {"rendering_time": rendering_time, "disk_writer_time" : disk_writer_time}
        return times

class Output2VideoDialog(QDialog):

    def __init__(self, dfh: DataFlowHandler, parent=None):
        super().__init__()

        self.setWindowTitle("Video Renderer")
        self.video_renderer = OutputVideoRenderer(dfh, self)

        self.layout = QVBoxLayout()
        self.layout.addWidget(self.video_renderer)
        self.setLayout(self.layout)

    def accept(self) -> None:
        print("Closing video renderer dialog")
        return

    @staticmethod
    def render_output(dfh: DataFlowHandler, parent=None):
        dialog = Output2VideoDialog(dfh, parent)
        dialog.exec()


class Output2VideoWindow(QMainWindow):
    
    def __init__(self, dfh: DataFlowHandler, parent=None):
        super().__init__(parent=parent)
        self.setWindowTitle("Video Renderer")
        self.video_renderer = OutputVideoRenderer(dfh, self)
        central_widget = self.video_renderer
        self.setCentralWidget(central_widget)

    def closeEvent(self, event: QCloseEvent) -> None:
        print("Closing video renderer dialog")
        self.video_renderer.unregister()
        return super().closeEvent(event)

if __name__ == "__main__":
    import sys
    app = QApplication(sys.argv)
    w = OutputVideoRenderer()
    w.show()
    sys.exit(app.exec_())


